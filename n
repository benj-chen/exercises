# Nice, you decided to peek into the file!  That's cool!
# This isn't meant to be securely encrypted or anything,
# just encoded enough that you'd have to make a conscious
# effort to read the code.
#
# Let me you did so!  Seriously, drop one of us (T or C) an
# email letting us know you found this.  We'll be pleased,
# I can assure you.  :)

#!/usr/bin/env python3

import contextlib
import collections
import random
import sys
import time

from subprocess import Popen, PIPE
from typing import Tuple, Mapping, List

# Time limits in seconds.
LIMIT_START = 10
LIMIT_TURN = 1
LIMIT_TOTAL = 2 * LIMIT_START + 60 * LIMIT_TURN

DIRS = [(dx,dy) for dx in range(-1,2) for dy in range(-1,2) if dx or dy]
OPP = {'w': 'b', 'b': 'w'}

# Convert between string and coordinate forms
def pos_decode(pos:str) -> Tuple[int, int]:
    return (ord(pos[0])-ord('a')), (ord(pos[1])-ord('1'))
def pos_encode(ij:Tuple[int, int]) -> str:
    return 'abcdefgh'[ij[0]] + '12345678'[ij[1]]

# Positions that would flip if (i,j) is filled by player.
def would_flip(board:Mapping[Tuple[int,int], str], i:int, j:int, player:str) -> List[Tuple[int,int]]:
    flips = []
    opponent = OPP[player]

    for dx,dy in DIRS:
        opps = []
        for step in range(1, 8):
            x, y = i+step*dx, j+step*dy
            if x<0 or x>=8 or y<0 or y>=8: break
            if board[x,y] == '':
                break
            elif board[x,y] == opponent:
                opps.append((x,y))
            elif board[x,y] == player:
                flips += opps
                break
    return flips

def valid_moves(board:Mapping[Tuple[int,int], str], player:str) -> List[Tuple[int,int]]:
    valid = []
    for (i,j) in [(x,y) for x in range(8) for y in range(8)]:
        if board[i,j]: continue
        if would_flip(board, i, j, player):
            valid.append((i,j))
    return valid

class PlayerExec:
    def __init__(self, cmd:str, bw:str):
        self.cmd = cmd
        self.bw = bw
        try:
            start = time.time()
            self.proc = Popen(f'timeout {LIMIT_TOTAL} {cmd}', shell=True, stdin=PIPE, stdout=PIPE)
            self.write(bw)
            assert self.read() == 'ok'
            if time.time() - start > LIMIT_START:
                self.over_time('init')
        except Exception as e:
            print(f'Exception when running "{cmd}": "{e}"')
            self.proc = None

    def write(self, text):
        msg = (text + '\n').encode('utf-8')
        self.proc.stdin.write(msg)
        self.proc.stdin.flush()

    def read(self):
        if self.proc is not None:
            return self.proc.stdout.readline().decode('utf-8').strip()
        else:
            return ''

    def stop(self):
        try:
            self.write('done')
            time.sleep(0.1)
            self.proc.terminate()
            time.sleep(0.1)
            self.proc.kill()
        except:
            pass
        self.proc = None

    def update(self, player:str, pos:str):
        try:
            start = time.time()
            self.write(f'move {player} {pos}')
            self.proc.stdin.flush()
            if time.time() - start > LIMIT_TURN:
                self.over_time('update')
        except:
            self.proc = None

    def get_move(self) -> str:
        try:
            start = time.time()
            self.write('get move')
            result = self.read()
            if time.time() - start > LIMIT_TURN:
                self.over_time('get_move')
            return result
        except:
            self.proc = None
            return None

    def over_time(self, reason):
        print(f'Player {self.bw}:{self.cmd} out of time during {reason}')
        self.stop()

class Game:
    def __init__(self, b, w):
        self.board = collections.defaultdict(str)
        self.players = {'b': b, 'w': w}
        self.current = 'b'
        self.mistakes = []
        self.turn = 0
    def opening(self):
        self._move('d4', 'b')
        self._move('d5', 'w')
        self._move('e5', 'b')
        self._move('e4', 'w')
    def done(self) -> bool:
        return not any(valid_moves(self.board, p) for p in 'bw')
    def next(self):
        moves = [pos_encode(m) for m in valid_moves(self.board, self.current)]
        if moves:
            move = self.players[self.current].get_move()
            if move not in moves:
                move2 = random.choice(moves)
                print('Playing random for', self.current, f'"{move2}" instead of "{move}"')
                self.mistakes.append((self.current, self.turn, move))
                move = move2
            self._move(move, self.current)
        self.current = OPP[self.current]
        self.turn += 1
    def _move(self, pos, player):
        assert type(pos) == str
        assert not self.board[pos_decode(pos)]

        i,j = pos_decode(pos)
        for p in would_flip(self.board, i, j, player):
            self.board[p] = player
        self.board[i, j] = player

        for p in self.players.values():
            p.update(player, pos)

    def summary(self) -> str:
        counts = collections.defaultdict(int)
        for tile in self.board.values():
            counts[tile] += 1
        return f"B:{counts['b']} W:{counts['w']}"

    def show_board(self) -> str:
        board_str = '    a b c d e f g h\n'
        board_str += '  +-----------------+\n'
        for y in range(8):
            board_str += '12345678'[y] + ' | '
            for x in range(8):
                board_str += self.board[x,y]  or '.'
                board_str += ' '
            board_str += '|\n'
        board_str += '  +-----------------+\n'
        return board_str

if len(sys.argv) >= 2:
    cmd_b = sys.argv[1]
else:
    cmd_b = input('Program to run for black: ')

if len(sys.argv) >= 3:
    cmd_w = sys.argv[2]
else:
    cmd_w = input('Program to run for white: ')

player_b = PlayerExec(cmd_b, 'b')
player_w = PlayerExec(cmd_w, 'w')

game = Game(player_b, player_w)
game.opening()
print('START')
print(game.show_board())

turns = 0
while not game.done():
    turns += 1
    game.next()
    print(game.show_board())

player_b.stop()
player_w.stop()

print('Final situation:', game.summary())
print(game.show_board())
for m in game.mistakes:
    print('MISTAKE:', m)


# Nice, you decided to peek into the file!  That's cool!
# This isn't meant to be securely encrypted or anything,
# just encoded enough that you'd have to make a conscious
# effort to read the code.
#
# Let me you did so!  Seriously, drop one of us (T or C) an
# email letting us know you found this.  We'll be pleased,
# I can assure you.  :)
